// Code generated by Prisma (prisma@1.34.6). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from 'graphql'
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model,
} from 'prisma-client-lib'
import { typeDefs } from './prisma-schema'

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U]

export type Maybe<T> = T | undefined | null

export interface Exists {
  property_rent_atom: (where?: property_rent_atomWhereInput) => Promise<boolean>
  property_sale_atom: (where?: property_sale_atomWhereInput) => Promise<boolean>
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>
}

export interface Prisma {
  $exists: Exists
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>

  /**
   * Queries
   */

  propertyRentAtom: (
    where: property_rent_atomWhereUniqueInput
  ) => property_rent_atomNullablePromise
  propertyRentAtoms: (args?: {
    where?: property_rent_atomWhereInput
    orderBy?: property_rent_atomOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<property_rent_atom>
  propertyRentAtomsConnection: (args?: {
    where?: property_rent_atomWhereInput
    orderBy?: property_rent_atomOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => property_rent_atomConnectionPromise
  propertySaleAtom: (
    where: property_sale_atomWhereUniqueInput
  ) => property_sale_atomNullablePromise
  propertySaleAtoms: (args?: {
    where?: property_sale_atomWhereInput
    orderBy?: property_sale_atomOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<property_sale_atom>
  propertySaleAtomsConnection: (args?: {
    where?: property_sale_atomWhereInput
    orderBy?: property_sale_atomOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => property_sale_atomConnectionPromise
  node: (args: { id: ID_Output }) => Node

  /**
   * Mutations
   */

  createproperty_rent_atom: (
    data: property_rent_atomCreateInput
  ) => property_rent_atomPromise
  updateproperty_rent_atom: (args: {
    data: property_rent_atomUpdateInput
    where: property_rent_atomWhereUniqueInput
  }) => property_rent_atomPromise
  updateManyproperty_rent_atoms: (args: {
    data: property_rent_atomUpdateManyMutationInput
    where?: property_rent_atomWhereInput
  }) => BatchPayloadPromise
  upsertproperty_rent_atom: (args: {
    where: property_rent_atomWhereUniqueInput
    create: property_rent_atomCreateInput
    update: property_rent_atomUpdateInput
  }) => property_rent_atomPromise
  deleteproperty_rent_atom: (
    where: property_rent_atomWhereUniqueInput
  ) => property_rent_atomPromise
  deleteManyproperty_rent_atoms: (
    where?: property_rent_atomWhereInput
  ) => BatchPayloadPromise
  createproperty_sale_atom: (
    data: property_sale_atomCreateInput
  ) => property_sale_atomPromise
  updateproperty_sale_atom: (args: {
    data: property_sale_atomUpdateInput
    where: property_sale_atomWhereUniqueInput
  }) => property_sale_atomPromise
  updateManyproperty_sale_atoms: (args: {
    data: property_sale_atomUpdateManyMutationInput
    where?: property_sale_atomWhereInput
  }) => BatchPayloadPromise
  upsertproperty_sale_atom: (args: {
    where: property_sale_atomWhereUniqueInput
    create: property_sale_atomCreateInput
    update: property_sale_atomUpdateInput
  }) => property_sale_atomPromise
  deleteproperty_sale_atom: (
    where: property_sale_atomWhereUniqueInput
  ) => property_sale_atomPromise
  deleteManyproperty_sale_atoms: (
    where?: property_sale_atomWhereInput
  ) => BatchPayloadPromise

  /**
   * Subscriptions
   */

  $subscribe: Subscription
}

export interface Subscription {
  propertyRentAtom: (
    where?: property_rent_atomSubscriptionWhereInput
  ) => property_rent_atomSubscriptionPayloadSubscription
  propertySaleAtom: (
    where?: property_sale_atomSubscriptionWhereInput
  ) => property_sale_atomSubscriptionPayloadSubscription
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T
}

/**
 * Types
 */

export type PropertyClass = 'PropertyRentAtom' | 'PropertySaleAtom'

export type property_rent_atomOrderByInput =
  | '_id_ASC'
  | '_id_DESC'
  | '_cls_ASC'
  | '_cls_DESC'
  | 'hash_key_ASC'
  | 'hash_key_DESC'
  | 'canonical_station_ASC'
  | 'canonical_station_DESC'
  | 'building_name_ASC'
  | 'building_name_DESC'
  | 'address_ASC'
  | 'address_DESC'
  | 'area_ASC'
  | 'area_DESC'
  | 'basic_rent_ASC'
  | 'basic_rent_DESC'
  | 'rent_plus_alpha_ASC'
  | 'rent_plus_alpha_DESC'
  | 'maintenance_fee_ASC'
  | 'maintenance_fee_DESC'
  | 'total_rent_ASC'
  | 'total_rent_DESC'
  | 'guarantee_money_multiple_ASC'
  | 'guarantee_money_multiple_DESC'
  | 'key_money_multiple_ASC'
  | 'key_money_multiple_DESC'
  | 'unit_rent_ASC'
  | 'unit_rent_DESC'
  | 'year_built_ASC'
  | 'year_built_DESC'
  | 'floor_plan_ASC'
  | 'floor_plan_DESC'
  | 'floor_number_ASC'
  | 'floor_number_DESC'
  | 'total_floor_ASC'
  | 'total_floor_DESC'
  | 'in_date_ASC'
  | 'in_date_DESC'
  | 'out_date_ASC'
  | 'out_date_DESC'
  | 'nearest_stations_ASC'
  | 'nearest_stations_DESC'
  | 'agent_comment_ASC'
  | 'agent_comment_DESC'
  | 'more_detail_ASC'
  | 'more_detail_DESC'

export type PropertyType = 'HOUSE' | 'MANSION' | 'APT'

export type property_sale_atomOrderByInput =
  | '_id_ASC'
  | '_id_DESC'
  | '_cls_ASC'
  | '_cls_DESC'
  | 'hash_key_ASC'
  | 'hash_key_DESC'
  | 'property_type_ASC'
  | 'property_type_DESC'
  | 'canonical_station_ASC'
  | 'canonical_station_DESC'
  | 'building_name_ASC'
  | 'building_name_DESC'
  | 'address_ASC'
  | 'address_DESC'
  | 'area_ASC'
  | 'area_DESC'
  | 'currency_ASC'
  | 'currency_DESC'
  | 'price_ASC'
  | 'price_DESC'
  | 'city_ASC'
  | 'city_DESC'
  | 'country_ASC'
  | 'country_DESC'
  | 'year_built_ASC'
  | 'year_built_DESC'
  | 'floor_plan_ASC'
  | 'floor_plan_DESC'
  | 'in_date_ASC'
  | 'in_date_DESC'
  | 'out_date_ASC'
  | 'out_date_DESC'
  | 'nearest_stations_ASC'
  | 'nearest_stations_DESC'
  | 'land_area_ASC'
  | 'land_area_DESC'
  | 'floor_number_ASC'
  | 'floor_number_DESC'
  | 'total_floor_ASC'
  | 'total_floor_DESC'
  | 'agent_comment_ASC'
  | 'agent_comment_DESC'
  | 'more_detail_ASC'
  | 'more_detail_DESC'

export type MutationType = 'CREATED' | 'UPDATED' | 'DELETED'

export type property_rent_atomWhereUniqueInput = AtLeastOne<{
  _id: Maybe<ID_Input>
  hash_key?: Maybe<String>
}>

export interface property_rent_atomWhereInput {
  _id?: Maybe<ID_Input>
  _id_not?: Maybe<ID_Input>
  _id_in?: Maybe<ID_Input[] | ID_Input>
  _id_not_in?: Maybe<ID_Input[] | ID_Input>
  _id_lt?: Maybe<ID_Input>
  _id_lte?: Maybe<ID_Input>
  _id_gt?: Maybe<ID_Input>
  _id_gte?: Maybe<ID_Input>
  _id_contains?: Maybe<ID_Input>
  _id_not_contains?: Maybe<ID_Input>
  _id_starts_with?: Maybe<ID_Input>
  _id_not_starts_with?: Maybe<ID_Input>
  _id_ends_with?: Maybe<ID_Input>
  _id_not_ends_with?: Maybe<ID_Input>
  _cls?: Maybe<PropertyClass>
  _cls_not?: Maybe<PropertyClass>
  _cls_in?: Maybe<PropertyClass[] | PropertyClass>
  _cls_not_in?: Maybe<PropertyClass[] | PropertyClass>
  hash_key?: Maybe<String>
  hash_key_not?: Maybe<String>
  hash_key_in?: Maybe<String[] | String>
  hash_key_not_in?: Maybe<String[] | String>
  hash_key_lt?: Maybe<String>
  hash_key_lte?: Maybe<String>
  hash_key_gt?: Maybe<String>
  hash_key_gte?: Maybe<String>
  hash_key_contains?: Maybe<String>
  hash_key_not_contains?: Maybe<String>
  hash_key_starts_with?: Maybe<String>
  hash_key_not_starts_with?: Maybe<String>
  hash_key_ends_with?: Maybe<String>
  hash_key_not_ends_with?: Maybe<String>
  canonical_station?: Maybe<String>
  canonical_station_not?: Maybe<String>
  canonical_station_in?: Maybe<String[] | String>
  canonical_station_not_in?: Maybe<String[] | String>
  canonical_station_lt?: Maybe<String>
  canonical_station_lte?: Maybe<String>
  canonical_station_gt?: Maybe<String>
  canonical_station_gte?: Maybe<String>
  canonical_station_contains?: Maybe<String>
  canonical_station_not_contains?: Maybe<String>
  canonical_station_starts_with?: Maybe<String>
  canonical_station_not_starts_with?: Maybe<String>
  canonical_station_ends_with?: Maybe<String>
  canonical_station_not_ends_with?: Maybe<String>
  building_name?: Maybe<String>
  building_name_not?: Maybe<String>
  building_name_in?: Maybe<String[] | String>
  building_name_not_in?: Maybe<String[] | String>
  building_name_lt?: Maybe<String>
  building_name_lte?: Maybe<String>
  building_name_gt?: Maybe<String>
  building_name_gte?: Maybe<String>
  building_name_contains?: Maybe<String>
  building_name_not_contains?: Maybe<String>
  building_name_starts_with?: Maybe<String>
  building_name_not_starts_with?: Maybe<String>
  building_name_ends_with?: Maybe<String>
  building_name_not_ends_with?: Maybe<String>
  address?: Maybe<String>
  address_not?: Maybe<String>
  address_in?: Maybe<String[] | String>
  address_not_in?: Maybe<String[] | String>
  address_lt?: Maybe<String>
  address_lte?: Maybe<String>
  address_gt?: Maybe<String>
  address_gte?: Maybe<String>
  address_contains?: Maybe<String>
  address_not_contains?: Maybe<String>
  address_starts_with?: Maybe<String>
  address_not_starts_with?: Maybe<String>
  address_ends_with?: Maybe<String>
  address_not_ends_with?: Maybe<String>
  area?: Maybe<Float>
  area_not?: Maybe<Float>
  area_in?: Maybe<Float[] | Float>
  area_not_in?: Maybe<Float[] | Float>
  area_lt?: Maybe<Float>
  area_lte?: Maybe<Float>
  area_gt?: Maybe<Float>
  area_gte?: Maybe<Float>
  basic_rent?: Maybe<Float>
  basic_rent_not?: Maybe<Float>
  basic_rent_in?: Maybe<Float[] | Float>
  basic_rent_not_in?: Maybe<Float[] | Float>
  basic_rent_lt?: Maybe<Float>
  basic_rent_lte?: Maybe<Float>
  basic_rent_gt?: Maybe<Float>
  basic_rent_gte?: Maybe<Float>
  rent_plus_alpha?: Maybe<Float>
  rent_plus_alpha_not?: Maybe<Float>
  rent_plus_alpha_in?: Maybe<Float[] | Float>
  rent_plus_alpha_not_in?: Maybe<Float[] | Float>
  rent_plus_alpha_lt?: Maybe<Float>
  rent_plus_alpha_lte?: Maybe<Float>
  rent_plus_alpha_gt?: Maybe<Float>
  rent_plus_alpha_gte?: Maybe<Float>
  maintenance_fee?: Maybe<Float>
  maintenance_fee_not?: Maybe<Float>
  maintenance_fee_in?: Maybe<Float[] | Float>
  maintenance_fee_not_in?: Maybe<Float[] | Float>
  maintenance_fee_lt?: Maybe<Float>
  maintenance_fee_lte?: Maybe<Float>
  maintenance_fee_gt?: Maybe<Float>
  maintenance_fee_gte?: Maybe<Float>
  total_rent?: Maybe<Float>
  total_rent_not?: Maybe<Float>
  total_rent_in?: Maybe<Float[] | Float>
  total_rent_not_in?: Maybe<Float[] | Float>
  total_rent_lt?: Maybe<Float>
  total_rent_lte?: Maybe<Float>
  total_rent_gt?: Maybe<Float>
  total_rent_gte?: Maybe<Float>
  guarantee_money_multiple?: Maybe<Float>
  guarantee_money_multiple_not?: Maybe<Float>
  guarantee_money_multiple_in?: Maybe<Float[] | Float>
  guarantee_money_multiple_not_in?: Maybe<Float[] | Float>
  guarantee_money_multiple_lt?: Maybe<Float>
  guarantee_money_multiple_lte?: Maybe<Float>
  guarantee_money_multiple_gt?: Maybe<Float>
  guarantee_money_multiple_gte?: Maybe<Float>
  key_money_multiple?: Maybe<Float>
  key_money_multiple_not?: Maybe<Float>
  key_money_multiple_in?: Maybe<Float[] | Float>
  key_money_multiple_not_in?: Maybe<Float[] | Float>
  key_money_multiple_lt?: Maybe<Float>
  key_money_multiple_lte?: Maybe<Float>
  key_money_multiple_gt?: Maybe<Float>
  key_money_multiple_gte?: Maybe<Float>
  unit_rent?: Maybe<Float>
  unit_rent_not?: Maybe<Float>
  unit_rent_in?: Maybe<Float[] | Float>
  unit_rent_not_in?: Maybe<Float[] | Float>
  unit_rent_lt?: Maybe<Float>
  unit_rent_lte?: Maybe<Float>
  unit_rent_gt?: Maybe<Float>
  unit_rent_gte?: Maybe<Float>
  year_built?: Maybe<Int>
  year_built_not?: Maybe<Int>
  year_built_in?: Maybe<Int[] | Int>
  year_built_not_in?: Maybe<Int[] | Int>
  year_built_lt?: Maybe<Int>
  year_built_lte?: Maybe<Int>
  year_built_gt?: Maybe<Int>
  year_built_gte?: Maybe<Int>
  floor_plan?: Maybe<String>
  floor_plan_not?: Maybe<String>
  floor_plan_in?: Maybe<String[] | String>
  floor_plan_not_in?: Maybe<String[] | String>
  floor_plan_lt?: Maybe<String>
  floor_plan_lte?: Maybe<String>
  floor_plan_gt?: Maybe<String>
  floor_plan_gte?: Maybe<String>
  floor_plan_contains?: Maybe<String>
  floor_plan_not_contains?: Maybe<String>
  floor_plan_starts_with?: Maybe<String>
  floor_plan_not_starts_with?: Maybe<String>
  floor_plan_ends_with?: Maybe<String>
  floor_plan_not_ends_with?: Maybe<String>
  floor_number?: Maybe<Int>
  floor_number_not?: Maybe<Int>
  floor_number_in?: Maybe<Int[] | Int>
  floor_number_not_in?: Maybe<Int[] | Int>
  floor_number_lt?: Maybe<Int>
  floor_number_lte?: Maybe<Int>
  floor_number_gt?: Maybe<Int>
  floor_number_gte?: Maybe<Int>
  total_floor?: Maybe<Int>
  total_floor_not?: Maybe<Int>
  total_floor_in?: Maybe<Int[] | Int>
  total_floor_not_in?: Maybe<Int[] | Int>
  total_floor_lt?: Maybe<Int>
  total_floor_lte?: Maybe<Int>
  total_floor_gt?: Maybe<Int>
  total_floor_gte?: Maybe<Int>
  in_date?: Maybe<DateTimeInput>
  in_date_not?: Maybe<DateTimeInput>
  in_date_in?: Maybe<DateTimeInput[] | DateTimeInput>
  in_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
  in_date_lt?: Maybe<DateTimeInput>
  in_date_lte?: Maybe<DateTimeInput>
  in_date_gt?: Maybe<DateTimeInput>
  in_date_gte?: Maybe<DateTimeInput>
  out_date?: Maybe<DateTimeInput>
  out_date_not?: Maybe<DateTimeInput>
  out_date_in?: Maybe<DateTimeInput[] | DateTimeInput>
  out_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
  out_date_lt?: Maybe<DateTimeInput>
  out_date_lte?: Maybe<DateTimeInput>
  out_date_gt?: Maybe<DateTimeInput>
  out_date_gte?: Maybe<DateTimeInput>
  agent_comment?: Maybe<String>
  agent_comment_not?: Maybe<String>
  agent_comment_in?: Maybe<String[] | String>
  agent_comment_not_in?: Maybe<String[] | String>
  agent_comment_lt?: Maybe<String>
  agent_comment_lte?: Maybe<String>
  agent_comment_gt?: Maybe<String>
  agent_comment_gte?: Maybe<String>
  agent_comment_contains?: Maybe<String>
  agent_comment_not_contains?: Maybe<String>
  agent_comment_starts_with?: Maybe<String>
  agent_comment_not_starts_with?: Maybe<String>
  agent_comment_ends_with?: Maybe<String>
  agent_comment_not_ends_with?: Maybe<String>
  more_detail?: Maybe<String>
  more_detail_not?: Maybe<String>
  more_detail_in?: Maybe<String[] | String>
  more_detail_not_in?: Maybe<String[] | String>
  more_detail_lt?: Maybe<String>
  more_detail_lte?: Maybe<String>
  more_detail_gt?: Maybe<String>
  more_detail_gte?: Maybe<String>
  more_detail_contains?: Maybe<String>
  more_detail_not_contains?: Maybe<String>
  more_detail_starts_with?: Maybe<String>
  more_detail_not_starts_with?: Maybe<String>
  more_detail_ends_with?: Maybe<String>
  more_detail_not_ends_with?: Maybe<String>
  AND?: Maybe<property_rent_atomWhereInput[] | property_rent_atomWhereInput>
}

export type property_sale_atomWhereUniqueInput = AtLeastOne<{
  _id: Maybe<ID_Input>
  hash_key?: Maybe<String>
}>

export interface property_sale_atomWhereInput {
  _id?: Maybe<ID_Input>
  _id_not?: Maybe<ID_Input>
  _id_in?: Maybe<ID_Input[] | ID_Input>
  _id_not_in?: Maybe<ID_Input[] | ID_Input>
  _id_lt?: Maybe<ID_Input>
  _id_lte?: Maybe<ID_Input>
  _id_gt?: Maybe<ID_Input>
  _id_gte?: Maybe<ID_Input>
  _id_contains?: Maybe<ID_Input>
  _id_not_contains?: Maybe<ID_Input>
  _id_starts_with?: Maybe<ID_Input>
  _id_not_starts_with?: Maybe<ID_Input>
  _id_ends_with?: Maybe<ID_Input>
  _id_not_ends_with?: Maybe<ID_Input>
  _cls?: Maybe<PropertyClass>
  _cls_not?: Maybe<PropertyClass>
  _cls_in?: Maybe<PropertyClass[] | PropertyClass>
  _cls_not_in?: Maybe<PropertyClass[] | PropertyClass>
  hash_key?: Maybe<String>
  hash_key_not?: Maybe<String>
  hash_key_in?: Maybe<String[] | String>
  hash_key_not_in?: Maybe<String[] | String>
  hash_key_lt?: Maybe<String>
  hash_key_lte?: Maybe<String>
  hash_key_gt?: Maybe<String>
  hash_key_gte?: Maybe<String>
  hash_key_contains?: Maybe<String>
  hash_key_not_contains?: Maybe<String>
  hash_key_starts_with?: Maybe<String>
  hash_key_not_starts_with?: Maybe<String>
  hash_key_ends_with?: Maybe<String>
  hash_key_not_ends_with?: Maybe<String>
  property_type?: Maybe<PropertyType>
  property_type_not?: Maybe<PropertyType>
  property_type_in?: Maybe<PropertyType[] | PropertyType>
  property_type_not_in?: Maybe<PropertyType[] | PropertyType>
  canonical_station?: Maybe<String>
  canonical_station_not?: Maybe<String>
  canonical_station_in?: Maybe<String[] | String>
  canonical_station_not_in?: Maybe<String[] | String>
  canonical_station_lt?: Maybe<String>
  canonical_station_lte?: Maybe<String>
  canonical_station_gt?: Maybe<String>
  canonical_station_gte?: Maybe<String>
  canonical_station_contains?: Maybe<String>
  canonical_station_not_contains?: Maybe<String>
  canonical_station_starts_with?: Maybe<String>
  canonical_station_not_starts_with?: Maybe<String>
  canonical_station_ends_with?: Maybe<String>
  canonical_station_not_ends_with?: Maybe<String>
  building_name?: Maybe<String>
  building_name_not?: Maybe<String>
  building_name_in?: Maybe<String[] | String>
  building_name_not_in?: Maybe<String[] | String>
  building_name_lt?: Maybe<String>
  building_name_lte?: Maybe<String>
  building_name_gt?: Maybe<String>
  building_name_gte?: Maybe<String>
  building_name_contains?: Maybe<String>
  building_name_not_contains?: Maybe<String>
  building_name_starts_with?: Maybe<String>
  building_name_not_starts_with?: Maybe<String>
  building_name_ends_with?: Maybe<String>
  building_name_not_ends_with?: Maybe<String>
  address?: Maybe<String>
  address_not?: Maybe<String>
  address_in?: Maybe<String[] | String>
  address_not_in?: Maybe<String[] | String>
  address_lt?: Maybe<String>
  address_lte?: Maybe<String>
  address_gt?: Maybe<String>
  address_gte?: Maybe<String>
  address_contains?: Maybe<String>
  address_not_contains?: Maybe<String>
  address_starts_with?: Maybe<String>
  address_not_starts_with?: Maybe<String>
  address_ends_with?: Maybe<String>
  address_not_ends_with?: Maybe<String>
  area?: Maybe<Float>
  area_not?: Maybe<Float>
  area_in?: Maybe<Float[] | Float>
  area_not_in?: Maybe<Float[] | Float>
  area_lt?: Maybe<Float>
  area_lte?: Maybe<Float>
  area_gt?: Maybe<Float>
  area_gte?: Maybe<Float>
  currency?: Maybe<String>
  currency_not?: Maybe<String>
  currency_in?: Maybe<String[] | String>
  currency_not_in?: Maybe<String[] | String>
  currency_lt?: Maybe<String>
  currency_lte?: Maybe<String>
  currency_gt?: Maybe<String>
  currency_gte?: Maybe<String>
  currency_contains?: Maybe<String>
  currency_not_contains?: Maybe<String>
  currency_starts_with?: Maybe<String>
  currency_not_starts_with?: Maybe<String>
  currency_ends_with?: Maybe<String>
  currency_not_ends_with?: Maybe<String>
  price?: Maybe<Float>
  price_not?: Maybe<Float>
  price_in?: Maybe<Float[] | Float>
  price_not_in?: Maybe<Float[] | Float>
  price_lt?: Maybe<Float>
  price_lte?: Maybe<Float>
  price_gt?: Maybe<Float>
  price_gte?: Maybe<Float>
  city?: Maybe<String>
  city_not?: Maybe<String>
  city_in?: Maybe<String[] | String>
  city_not_in?: Maybe<String[] | String>
  city_lt?: Maybe<String>
  city_lte?: Maybe<String>
  city_gt?: Maybe<String>
  city_gte?: Maybe<String>
  city_contains?: Maybe<String>
  city_not_contains?: Maybe<String>
  city_starts_with?: Maybe<String>
  city_not_starts_with?: Maybe<String>
  city_ends_with?: Maybe<String>
  city_not_ends_with?: Maybe<String>
  country?: Maybe<String>
  country_not?: Maybe<String>
  country_in?: Maybe<String[] | String>
  country_not_in?: Maybe<String[] | String>
  country_lt?: Maybe<String>
  country_lte?: Maybe<String>
  country_gt?: Maybe<String>
  country_gte?: Maybe<String>
  country_contains?: Maybe<String>
  country_not_contains?: Maybe<String>
  country_starts_with?: Maybe<String>
  country_not_starts_with?: Maybe<String>
  country_ends_with?: Maybe<String>
  country_not_ends_with?: Maybe<String>
  year_built?: Maybe<Int>
  year_built_not?: Maybe<Int>
  year_built_in?: Maybe<Int[] | Int>
  year_built_not_in?: Maybe<Int[] | Int>
  year_built_lt?: Maybe<Int>
  year_built_lte?: Maybe<Int>
  year_built_gt?: Maybe<Int>
  year_built_gte?: Maybe<Int>
  floor_plan?: Maybe<String>
  floor_plan_not?: Maybe<String>
  floor_plan_in?: Maybe<String[] | String>
  floor_plan_not_in?: Maybe<String[] | String>
  floor_plan_lt?: Maybe<String>
  floor_plan_lte?: Maybe<String>
  floor_plan_gt?: Maybe<String>
  floor_plan_gte?: Maybe<String>
  floor_plan_contains?: Maybe<String>
  floor_plan_not_contains?: Maybe<String>
  floor_plan_starts_with?: Maybe<String>
  floor_plan_not_starts_with?: Maybe<String>
  floor_plan_ends_with?: Maybe<String>
  floor_plan_not_ends_with?: Maybe<String>
  in_date?: Maybe<DateTimeInput>
  in_date_not?: Maybe<DateTimeInput>
  in_date_in?: Maybe<DateTimeInput[] | DateTimeInput>
  in_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
  in_date_lt?: Maybe<DateTimeInput>
  in_date_lte?: Maybe<DateTimeInput>
  in_date_gt?: Maybe<DateTimeInput>
  in_date_gte?: Maybe<DateTimeInput>
  out_date?: Maybe<DateTimeInput>
  out_date_not?: Maybe<DateTimeInput>
  out_date_in?: Maybe<DateTimeInput[] | DateTimeInput>
  out_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
  out_date_lt?: Maybe<DateTimeInput>
  out_date_lte?: Maybe<DateTimeInput>
  out_date_gt?: Maybe<DateTimeInput>
  out_date_gte?: Maybe<DateTimeInput>
  land_area?: Maybe<Float>
  land_area_not?: Maybe<Float>
  land_area_in?: Maybe<Float[] | Float>
  land_area_not_in?: Maybe<Float[] | Float>
  land_area_lt?: Maybe<Float>
  land_area_lte?: Maybe<Float>
  land_area_gt?: Maybe<Float>
  land_area_gte?: Maybe<Float>
  floor_number?: Maybe<Int>
  floor_number_not?: Maybe<Int>
  floor_number_in?: Maybe<Int[] | Int>
  floor_number_not_in?: Maybe<Int[] | Int>
  floor_number_lt?: Maybe<Int>
  floor_number_lte?: Maybe<Int>
  floor_number_gt?: Maybe<Int>
  floor_number_gte?: Maybe<Int>
  total_floor?: Maybe<Int>
  total_floor_not?: Maybe<Int>
  total_floor_in?: Maybe<Int[] | Int>
  total_floor_not_in?: Maybe<Int[] | Int>
  total_floor_lt?: Maybe<Int>
  total_floor_lte?: Maybe<Int>
  total_floor_gt?: Maybe<Int>
  total_floor_gte?: Maybe<Int>
  agent_comment?: Maybe<String>
  agent_comment_not?: Maybe<String>
  agent_comment_in?: Maybe<String[] | String>
  agent_comment_not_in?: Maybe<String[] | String>
  agent_comment_lt?: Maybe<String>
  agent_comment_lte?: Maybe<String>
  agent_comment_gt?: Maybe<String>
  agent_comment_gte?: Maybe<String>
  agent_comment_contains?: Maybe<String>
  agent_comment_not_contains?: Maybe<String>
  agent_comment_starts_with?: Maybe<String>
  agent_comment_not_starts_with?: Maybe<String>
  agent_comment_ends_with?: Maybe<String>
  agent_comment_not_ends_with?: Maybe<String>
  more_detail?: Maybe<String>
  more_detail_not?: Maybe<String>
  more_detail_in?: Maybe<String[] | String>
  more_detail_not_in?: Maybe<String[] | String>
  more_detail_lt?: Maybe<String>
  more_detail_lte?: Maybe<String>
  more_detail_gt?: Maybe<String>
  more_detail_gte?: Maybe<String>
  more_detail_contains?: Maybe<String>
  more_detail_not_contains?: Maybe<String>
  more_detail_starts_with?: Maybe<String>
  more_detail_not_starts_with?: Maybe<String>
  more_detail_ends_with?: Maybe<String>
  more_detail_not_ends_with?: Maybe<String>
  AND?: Maybe<property_sale_atomWhereInput[] | property_sale_atomWhereInput>
}

export interface property_rent_atomCreateInput {
  _id?: Maybe<ID_Input>
  _cls?: Maybe<PropertyClass>
  hash_key: String
  canonical_station?: Maybe<String>
  building_name?: Maybe<String>
  address?: Maybe<String>
  area?: Maybe<Float>
  basic_rent?: Maybe<Float>
  rent_plus_alpha?: Maybe<Float>
  maintenance_fee?: Maybe<Float>
  total_rent?: Maybe<Float>
  guarantee_money_multiple?: Maybe<Float>
  key_money_multiple?: Maybe<Float>
  unit_rent?: Maybe<Float>
  year_built?: Maybe<Int>
  floor_plan?: Maybe<String>
  floor_number?: Maybe<Int>
  total_floor?: Maybe<Int>
  in_date?: Maybe<DateTimeInput>
  out_date?: Maybe<DateTimeInput>
  nearest_stations?: Maybe<Json>
  agent_comment?: Maybe<String>
  more_detail?: Maybe<String>
}

export interface property_rent_atomUpdateInput {
  _cls?: Maybe<PropertyClass>
  hash_key?: Maybe<String>
  canonical_station?: Maybe<String>
  building_name?: Maybe<String>
  address?: Maybe<String>
  area?: Maybe<Float>
  basic_rent?: Maybe<Float>
  rent_plus_alpha?: Maybe<Float>
  maintenance_fee?: Maybe<Float>
  total_rent?: Maybe<Float>
  guarantee_money_multiple?: Maybe<Float>
  key_money_multiple?: Maybe<Float>
  unit_rent?: Maybe<Float>
  year_built?: Maybe<Int>
  floor_plan?: Maybe<String>
  floor_number?: Maybe<Int>
  total_floor?: Maybe<Int>
  in_date?: Maybe<DateTimeInput>
  out_date?: Maybe<DateTimeInput>
  nearest_stations?: Maybe<Json>
  agent_comment?: Maybe<String>
  more_detail?: Maybe<String>
}

export interface property_rent_atomUpdateManyMutationInput {
  _cls?: Maybe<PropertyClass>
  hash_key?: Maybe<String>
  canonical_station?: Maybe<String>
  building_name?: Maybe<String>
  address?: Maybe<String>
  area?: Maybe<Float>
  basic_rent?: Maybe<Float>
  rent_plus_alpha?: Maybe<Float>
  maintenance_fee?: Maybe<Float>
  total_rent?: Maybe<Float>
  guarantee_money_multiple?: Maybe<Float>
  key_money_multiple?: Maybe<Float>
  unit_rent?: Maybe<Float>
  year_built?: Maybe<Int>
  floor_plan?: Maybe<String>
  floor_number?: Maybe<Int>
  total_floor?: Maybe<Int>
  in_date?: Maybe<DateTimeInput>
  out_date?: Maybe<DateTimeInput>
  nearest_stations?: Maybe<Json>
  agent_comment?: Maybe<String>
  more_detail?: Maybe<String>
}

export interface property_sale_atomCreateInput {
  _id?: Maybe<ID_Input>
  _cls?: Maybe<PropertyClass>
  hash_key: String
  property_type: PropertyType
  canonical_station?: Maybe<String>
  building_name?: Maybe<String>
  address?: Maybe<String>
  area?: Maybe<Float>
  currency?: Maybe<String>
  price?: Maybe<Float>
  city?: Maybe<String>
  country?: Maybe<String>
  year_built?: Maybe<Int>
  floor_plan?: Maybe<String>
  in_date?: Maybe<DateTimeInput>
  out_date?: Maybe<DateTimeInput>
  nearest_stations?: Maybe<Json>
  land_area?: Maybe<Float>
  floor_number?: Maybe<Int>
  total_floor?: Maybe<Int>
  agent_comment?: Maybe<String>
  more_detail?: Maybe<String>
}

export interface property_sale_atomUpdateInput {
  _cls?: Maybe<PropertyClass>
  hash_key?: Maybe<String>
  property_type?: Maybe<PropertyType>
  canonical_station?: Maybe<String>
  building_name?: Maybe<String>
  address?: Maybe<String>
  area?: Maybe<Float>
  currency?: Maybe<String>
  price?: Maybe<Float>
  city?: Maybe<String>
  country?: Maybe<String>
  year_built?: Maybe<Int>
  floor_plan?: Maybe<String>
  in_date?: Maybe<DateTimeInput>
  out_date?: Maybe<DateTimeInput>
  nearest_stations?: Maybe<Json>
  land_area?: Maybe<Float>
  floor_number?: Maybe<Int>
  total_floor?: Maybe<Int>
  agent_comment?: Maybe<String>
  more_detail?: Maybe<String>
}

export interface property_sale_atomUpdateManyMutationInput {
  _cls?: Maybe<PropertyClass>
  hash_key?: Maybe<String>
  property_type?: Maybe<PropertyType>
  canonical_station?: Maybe<String>
  building_name?: Maybe<String>
  address?: Maybe<String>
  area?: Maybe<Float>
  currency?: Maybe<String>
  price?: Maybe<Float>
  city?: Maybe<String>
  country?: Maybe<String>
  year_built?: Maybe<Int>
  floor_plan?: Maybe<String>
  in_date?: Maybe<DateTimeInput>
  out_date?: Maybe<DateTimeInput>
  nearest_stations?: Maybe<Json>
  land_area?: Maybe<Float>
  floor_number?: Maybe<Int>
  total_floor?: Maybe<Int>
  agent_comment?: Maybe<String>
  more_detail?: Maybe<String>
}

export interface property_rent_atomSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>
  updatedFields_contains?: Maybe<String>
  updatedFields_contains_every?: Maybe<String[] | String>
  updatedFields_contains_some?: Maybe<String[] | String>
  node?: Maybe<property_rent_atomWhereInput>
  AND?: Maybe<
    | property_rent_atomSubscriptionWhereInput[]
    | property_rent_atomSubscriptionWhereInput
  >
}

export interface property_sale_atomSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>
  updatedFields_contains?: Maybe<String>
  updatedFields_contains_every?: Maybe<String[] | String>
  updatedFields_contains_some?: Maybe<String[] | String>
  node?: Maybe<property_sale_atomWhereInput>
  AND?: Maybe<
    | property_sale_atomSubscriptionWhereInput[]
    | property_sale_atomSubscriptionWhereInput
  >
}

export interface NodeNode {
  id: ID_Output
}

export interface property_rent_atom {
  _id: ID_Output
  _cls: PropertyClass
  hash_key: String
  canonical_station?: String
  building_name?: String
  address?: String
  area?: Float
  basic_rent?: Float
  rent_plus_alpha?: Float
  maintenance_fee?: Float
  total_rent?: Float
  guarantee_money_multiple?: Float
  key_money_multiple?: Float
  unit_rent?: Float
  year_built?: Int
  floor_plan?: String
  floor_number?: Int
  total_floor?: Int
  in_date?: DateTimeOutput
  out_date?: DateTimeOutput
  nearest_stations?: Json
  agent_comment?: String
  more_detail?: String
}

export interface property_rent_atomPromise
  extends Promise<property_rent_atom>,
    Fragmentable {
  _id: () => Promise<ID_Output>
  _cls: () => Promise<PropertyClass>
  hash_key: () => Promise<String>
  canonical_station: () => Promise<String>
  building_name: () => Promise<String>
  address: () => Promise<String>
  area: () => Promise<Float>
  basic_rent: () => Promise<Float>
  rent_plus_alpha: () => Promise<Float>
  maintenance_fee: () => Promise<Float>
  total_rent: () => Promise<Float>
  guarantee_money_multiple: () => Promise<Float>
  key_money_multiple: () => Promise<Float>
  unit_rent: () => Promise<Float>
  year_built: () => Promise<Int>
  floor_plan: () => Promise<String>
  floor_number: () => Promise<Int>
  total_floor: () => Promise<Int>
  in_date: () => Promise<DateTimeOutput>
  out_date: () => Promise<DateTimeOutput>
  nearest_stations: () => Promise<Json>
  agent_comment: () => Promise<String>
  more_detail: () => Promise<String>
}

export interface property_rent_atomSubscription
  extends Promise<AsyncIterator<property_rent_atom>>,
    Fragmentable {
  _id: () => Promise<AsyncIterator<ID_Output>>
  _cls: () => Promise<AsyncIterator<PropertyClass>>
  hash_key: () => Promise<AsyncIterator<String>>
  canonical_station: () => Promise<AsyncIterator<String>>
  building_name: () => Promise<AsyncIterator<String>>
  address: () => Promise<AsyncIterator<String>>
  area: () => Promise<AsyncIterator<Float>>
  basic_rent: () => Promise<AsyncIterator<Float>>
  rent_plus_alpha: () => Promise<AsyncIterator<Float>>
  maintenance_fee: () => Promise<AsyncIterator<Float>>
  total_rent: () => Promise<AsyncIterator<Float>>
  guarantee_money_multiple: () => Promise<AsyncIterator<Float>>
  key_money_multiple: () => Promise<AsyncIterator<Float>>
  unit_rent: () => Promise<AsyncIterator<Float>>
  year_built: () => Promise<AsyncIterator<Int>>
  floor_plan: () => Promise<AsyncIterator<String>>
  floor_number: () => Promise<AsyncIterator<Int>>
  total_floor: () => Promise<AsyncIterator<Int>>
  in_date: () => Promise<AsyncIterator<DateTimeOutput>>
  out_date: () => Promise<AsyncIterator<DateTimeOutput>>
  nearest_stations: () => Promise<AsyncIterator<Json>>
  agent_comment: () => Promise<AsyncIterator<String>>
  more_detail: () => Promise<AsyncIterator<String>>
}

export interface property_rent_atomNullablePromise
  extends Promise<property_rent_atom | null>,
    Fragmentable {
  _id: () => Promise<ID_Output>
  _cls: () => Promise<PropertyClass>
  hash_key: () => Promise<String>
  canonical_station: () => Promise<String>
  building_name: () => Promise<String>
  address: () => Promise<String>
  area: () => Promise<Float>
  basic_rent: () => Promise<Float>
  rent_plus_alpha: () => Promise<Float>
  maintenance_fee: () => Promise<Float>
  total_rent: () => Promise<Float>
  guarantee_money_multiple: () => Promise<Float>
  key_money_multiple: () => Promise<Float>
  unit_rent: () => Promise<Float>
  year_built: () => Promise<Int>
  floor_plan: () => Promise<String>
  floor_number: () => Promise<Int>
  total_floor: () => Promise<Int>
  in_date: () => Promise<DateTimeOutput>
  out_date: () => Promise<DateTimeOutput>
  nearest_stations: () => Promise<Json>
  agent_comment: () => Promise<String>
  more_detail: () => Promise<String>
}

export interface property_rent_atomConnection {
  pageInfo: PageInfo
  edges: property_rent_atomEdge[]
}

export interface property_rent_atomConnectionPromise
  extends Promise<property_rent_atomConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<property_rent_atomEdge>>() => T
  aggregate: <T = Aggregateproperty_rent_atomPromise>() => T
}

export interface property_rent_atomConnectionSubscription
  extends Promise<AsyncIterator<property_rent_atomConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<property_rent_atomEdgeSubscription>>>() => T
  aggregate: <T = Aggregateproperty_rent_atomSubscription>() => T
}

export interface PageInfo {
  hasNextPage: Boolean
  hasPreviousPage: Boolean
  startCursor?: String
  endCursor?: String
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>
  hasPreviousPage: () => Promise<Boolean>
  startCursor: () => Promise<String>
  endCursor: () => Promise<String>
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>
  startCursor: () => Promise<AsyncIterator<String>>
  endCursor: () => Promise<AsyncIterator<String>>
}

export interface property_rent_atomEdge {
  node: property_rent_atom
  cursor: String
}

export interface property_rent_atomEdgePromise
  extends Promise<property_rent_atomEdge>,
    Fragmentable {
  node: <T = property_rent_atomPromise>() => T
  cursor: () => Promise<String>
}

export interface property_rent_atomEdgeSubscription
  extends Promise<AsyncIterator<property_rent_atomEdge>>,
    Fragmentable {
  node: <T = property_rent_atomSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface Aggregateproperty_rent_atom {
  count: Int
}

export interface Aggregateproperty_rent_atomPromise
  extends Promise<Aggregateproperty_rent_atom>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface Aggregateproperty_rent_atomSubscription
  extends Promise<AsyncIterator<Aggregateproperty_rent_atom>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface property_sale_atom {
  _id: ID_Output
  _cls: PropertyClass
  hash_key: String
  property_type: PropertyType
  canonical_station?: String
  building_name?: String
  address?: String
  area?: Float
  currency?: String
  price?: Float
  city?: String
  country?: String
  year_built?: Int
  floor_plan?: String
  in_date?: DateTimeOutput
  out_date?: DateTimeOutput
  nearest_stations?: Json
  land_area?: Float
  floor_number?: Int
  total_floor?: Int
  agent_comment?: String
  more_detail?: String
}

export interface property_sale_atomPromise
  extends Promise<property_sale_atom>,
    Fragmentable {
  _id: () => Promise<ID_Output>
  _cls: () => Promise<PropertyClass>
  hash_key: () => Promise<String>
  property_type: () => Promise<PropertyType>
  canonical_station: () => Promise<String>
  building_name: () => Promise<String>
  address: () => Promise<String>
  area: () => Promise<Float>
  currency: () => Promise<String>
  price: () => Promise<Float>
  city: () => Promise<String>
  country: () => Promise<String>
  year_built: () => Promise<Int>
  floor_plan: () => Promise<String>
  in_date: () => Promise<DateTimeOutput>
  out_date: () => Promise<DateTimeOutput>
  nearest_stations: () => Promise<Json>
  land_area: () => Promise<Float>
  floor_number: () => Promise<Int>
  total_floor: () => Promise<Int>
  agent_comment: () => Promise<String>
  more_detail: () => Promise<String>
}

export interface property_sale_atomSubscription
  extends Promise<AsyncIterator<property_sale_atom>>,
    Fragmentable {
  _id: () => Promise<AsyncIterator<ID_Output>>
  _cls: () => Promise<AsyncIterator<PropertyClass>>
  hash_key: () => Promise<AsyncIterator<String>>
  property_type: () => Promise<AsyncIterator<PropertyType>>
  canonical_station: () => Promise<AsyncIterator<String>>
  building_name: () => Promise<AsyncIterator<String>>
  address: () => Promise<AsyncIterator<String>>
  area: () => Promise<AsyncIterator<Float>>
  currency: () => Promise<AsyncIterator<String>>
  price: () => Promise<AsyncIterator<Float>>
  city: () => Promise<AsyncIterator<String>>
  country: () => Promise<AsyncIterator<String>>
  year_built: () => Promise<AsyncIterator<Int>>
  floor_plan: () => Promise<AsyncIterator<String>>
  in_date: () => Promise<AsyncIterator<DateTimeOutput>>
  out_date: () => Promise<AsyncIterator<DateTimeOutput>>
  nearest_stations: () => Promise<AsyncIterator<Json>>
  land_area: () => Promise<AsyncIterator<Float>>
  floor_number: () => Promise<AsyncIterator<Int>>
  total_floor: () => Promise<AsyncIterator<Int>>
  agent_comment: () => Promise<AsyncIterator<String>>
  more_detail: () => Promise<AsyncIterator<String>>
}

export interface property_sale_atomNullablePromise
  extends Promise<property_sale_atom | null>,
    Fragmentable {
  _id: () => Promise<ID_Output>
  _cls: () => Promise<PropertyClass>
  hash_key: () => Promise<String>
  property_type: () => Promise<PropertyType>
  canonical_station: () => Promise<String>
  building_name: () => Promise<String>
  address: () => Promise<String>
  area: () => Promise<Float>
  currency: () => Promise<String>
  price: () => Promise<Float>
  city: () => Promise<String>
  country: () => Promise<String>
  year_built: () => Promise<Int>
  floor_plan: () => Promise<String>
  in_date: () => Promise<DateTimeOutput>
  out_date: () => Promise<DateTimeOutput>
  nearest_stations: () => Promise<Json>
  land_area: () => Promise<Float>
  floor_number: () => Promise<Int>
  total_floor: () => Promise<Int>
  agent_comment: () => Promise<String>
  more_detail: () => Promise<String>
}

export interface property_sale_atomConnection {
  pageInfo: PageInfo
  edges: property_sale_atomEdge[]
}

export interface property_sale_atomConnectionPromise
  extends Promise<property_sale_atomConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<property_sale_atomEdge>>() => T
  aggregate: <T = Aggregateproperty_sale_atomPromise>() => T
}

export interface property_sale_atomConnectionSubscription
  extends Promise<AsyncIterator<property_sale_atomConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<property_sale_atomEdgeSubscription>>>() => T
  aggregate: <T = Aggregateproperty_sale_atomSubscription>() => T
}

export interface property_sale_atomEdge {
  node: property_sale_atom
  cursor: String
}

export interface property_sale_atomEdgePromise
  extends Promise<property_sale_atomEdge>,
    Fragmentable {
  node: <T = property_sale_atomPromise>() => T
  cursor: () => Promise<String>
}

export interface property_sale_atomEdgeSubscription
  extends Promise<AsyncIterator<property_sale_atomEdge>>,
    Fragmentable {
  node: <T = property_sale_atomSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface Aggregateproperty_sale_atom {
  count: Int
}

export interface Aggregateproperty_sale_atomPromise
  extends Promise<Aggregateproperty_sale_atom>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface Aggregateproperty_sale_atomSubscription
  extends Promise<AsyncIterator<Aggregateproperty_sale_atom>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface BatchPayload {
  count: Long
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>
}

export interface property_rent_atomSubscriptionPayload {
  mutation: MutationType
  node: property_rent_atom
  updatedFields: String[]
  previousValues: property_rent_atomPreviousValues
}

export interface property_rent_atomSubscriptionPayloadPromise
  extends Promise<property_rent_atomSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = property_rent_atomPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = property_rent_atomPreviousValuesPromise>() => T
}

export interface property_rent_atomSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<property_rent_atomSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = property_rent_atomSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = property_rent_atomPreviousValuesSubscription>() => T
}

export interface property_rent_atomPreviousValues {
  _id: ID_Output
  _cls: PropertyClass
  hash_key: String
  canonical_station?: String
  building_name?: String
  address?: String
  area?: Float
  basic_rent?: Float
  rent_plus_alpha?: Float
  maintenance_fee?: Float
  total_rent?: Float
  guarantee_money_multiple?: Float
  key_money_multiple?: Float
  unit_rent?: Float
  year_built?: Int
  floor_plan?: String
  floor_number?: Int
  total_floor?: Int
  in_date?: DateTimeOutput
  out_date?: DateTimeOutput
  nearest_stations?: Json
  agent_comment?: String
  more_detail?: String
}

export interface property_rent_atomPreviousValuesPromise
  extends Promise<property_rent_atomPreviousValues>,
    Fragmentable {
  _id: () => Promise<ID_Output>
  _cls: () => Promise<PropertyClass>
  hash_key: () => Promise<String>
  canonical_station: () => Promise<String>
  building_name: () => Promise<String>
  address: () => Promise<String>
  area: () => Promise<Float>
  basic_rent: () => Promise<Float>
  rent_plus_alpha: () => Promise<Float>
  maintenance_fee: () => Promise<Float>
  total_rent: () => Promise<Float>
  guarantee_money_multiple: () => Promise<Float>
  key_money_multiple: () => Promise<Float>
  unit_rent: () => Promise<Float>
  year_built: () => Promise<Int>
  floor_plan: () => Promise<String>
  floor_number: () => Promise<Int>
  total_floor: () => Promise<Int>
  in_date: () => Promise<DateTimeOutput>
  out_date: () => Promise<DateTimeOutput>
  nearest_stations: () => Promise<Json>
  agent_comment: () => Promise<String>
  more_detail: () => Promise<String>
}

export interface property_rent_atomPreviousValuesSubscription
  extends Promise<AsyncIterator<property_rent_atomPreviousValues>>,
    Fragmentable {
  _id: () => Promise<AsyncIterator<ID_Output>>
  _cls: () => Promise<AsyncIterator<PropertyClass>>
  hash_key: () => Promise<AsyncIterator<String>>
  canonical_station: () => Promise<AsyncIterator<String>>
  building_name: () => Promise<AsyncIterator<String>>
  address: () => Promise<AsyncIterator<String>>
  area: () => Promise<AsyncIterator<Float>>
  basic_rent: () => Promise<AsyncIterator<Float>>
  rent_plus_alpha: () => Promise<AsyncIterator<Float>>
  maintenance_fee: () => Promise<AsyncIterator<Float>>
  total_rent: () => Promise<AsyncIterator<Float>>
  guarantee_money_multiple: () => Promise<AsyncIterator<Float>>
  key_money_multiple: () => Promise<AsyncIterator<Float>>
  unit_rent: () => Promise<AsyncIterator<Float>>
  year_built: () => Promise<AsyncIterator<Int>>
  floor_plan: () => Promise<AsyncIterator<String>>
  floor_number: () => Promise<AsyncIterator<Int>>
  total_floor: () => Promise<AsyncIterator<Int>>
  in_date: () => Promise<AsyncIterator<DateTimeOutput>>
  out_date: () => Promise<AsyncIterator<DateTimeOutput>>
  nearest_stations: () => Promise<AsyncIterator<Json>>
  agent_comment: () => Promise<AsyncIterator<String>>
  more_detail: () => Promise<AsyncIterator<String>>
}

export interface property_sale_atomSubscriptionPayload {
  mutation: MutationType
  node: property_sale_atom
  updatedFields: String[]
  previousValues: property_sale_atomPreviousValues
}

export interface property_sale_atomSubscriptionPayloadPromise
  extends Promise<property_sale_atomSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = property_sale_atomPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = property_sale_atomPreviousValuesPromise>() => T
}

export interface property_sale_atomSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<property_sale_atomSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = property_sale_atomSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = property_sale_atomPreviousValuesSubscription>() => T
}

export interface property_sale_atomPreviousValues {
  _id: ID_Output
  _cls: PropertyClass
  hash_key: String
  property_type: PropertyType
  canonical_station?: String
  building_name?: String
  address?: String
  area?: Float
  currency?: String
  price?: Float
  city?: String
  country?: String
  year_built?: Int
  floor_plan?: String
  in_date?: DateTimeOutput
  out_date?: DateTimeOutput
  nearest_stations?: Json
  land_area?: Float
  floor_number?: Int
  total_floor?: Int
  agent_comment?: String
  more_detail?: String
}

export interface property_sale_atomPreviousValuesPromise
  extends Promise<property_sale_atomPreviousValues>,
    Fragmentable {
  _id: () => Promise<ID_Output>
  _cls: () => Promise<PropertyClass>
  hash_key: () => Promise<String>
  property_type: () => Promise<PropertyType>
  canonical_station: () => Promise<String>
  building_name: () => Promise<String>
  address: () => Promise<String>
  area: () => Promise<Float>
  currency: () => Promise<String>
  price: () => Promise<Float>
  city: () => Promise<String>
  country: () => Promise<String>
  year_built: () => Promise<Int>
  floor_plan: () => Promise<String>
  in_date: () => Promise<DateTimeOutput>
  out_date: () => Promise<DateTimeOutput>
  nearest_stations: () => Promise<Json>
  land_area: () => Promise<Float>
  floor_number: () => Promise<Int>
  total_floor: () => Promise<Int>
  agent_comment: () => Promise<String>
  more_detail: () => Promise<String>
}

export interface property_sale_atomPreviousValuesSubscription
  extends Promise<AsyncIterator<property_sale_atomPreviousValues>>,
    Fragmentable {
  _id: () => Promise<AsyncIterator<ID_Output>>
  _cls: () => Promise<AsyncIterator<PropertyClass>>
  hash_key: () => Promise<AsyncIterator<String>>
  property_type: () => Promise<AsyncIterator<PropertyType>>
  canonical_station: () => Promise<AsyncIterator<String>>
  building_name: () => Promise<AsyncIterator<String>>
  address: () => Promise<AsyncIterator<String>>
  area: () => Promise<AsyncIterator<Float>>
  currency: () => Promise<AsyncIterator<String>>
  price: () => Promise<AsyncIterator<Float>>
  city: () => Promise<AsyncIterator<String>>
  country: () => Promise<AsyncIterator<String>>
  year_built: () => Promise<AsyncIterator<Int>>
  floor_plan: () => Promise<AsyncIterator<String>>
  in_date: () => Promise<AsyncIterator<DateTimeOutput>>
  out_date: () => Promise<AsyncIterator<DateTimeOutput>>
  nearest_stations: () => Promise<AsyncIterator<Json>>
  land_area: () => Promise<AsyncIterator<Float>>
  floor_number: () => Promise<AsyncIterator<Int>>
  total_floor: () => Promise<AsyncIterator<Int>>
  agent_comment: () => Promise<AsyncIterator<String>>
  more_detail: () => Promise<AsyncIterator<String>>
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number
export type ID_Output = string

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string

export type Json = any

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean

export type Long = string

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: 'PropertyClass',
    embedded: false,
  },
  {
    name: 'PropertyType',
    embedded: false,
  },
  {
    name: 'property_rent_atom',
    embedded: false,
  },
  {
    name: 'property_sale_atom',
    embedded: false,
  },
]

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`,
})
export const prisma = new Prisma()
